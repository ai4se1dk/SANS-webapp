---
phase: 01-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sans_webapp/services/mcp_state_bridge.py
  - src/sans_webapp/mcp_server.py
autonomous: true

must_haves:
  truths:
    - "SessionStateBridge has methods to set parameter widget state (value, min, max, vary)"
    - "MCP tools modify session state only through bridge methods"
    - "After any state-modifying tool executes, needs_rerun flag is set"
    - "No direct _state_accessor access remains in mcp_server.py"
  artifacts:
    - path: "src/sans_webapp/services/mcp_state_bridge.py"
      provides: "Parameter widget setter methods"
      contains: "set_parameter_value"
    - path: "src/sans_webapp/services/mcp_state_bridge.py"
      provides: "Parameter widget setter methods"
      contains: "set_parameter_widget"
    - path: "src/sans_webapp/mcp_server.py"
      provides: "Refactored tools using bridge"
      contains: "get_state_bridge()"
  key_links:
    - from: "src/sans_webapp/mcp_server.py"
      to: "src/sans_webapp/services/mcp_state_bridge.py"
      via: "import and use of get_state_bridge()"
      pattern: "from sans_webapp.services.mcp_state_bridge import get_state_bridge"
    - from: "src/sans_webapp/mcp_server.py:set_model"
      to: "bridge.set_parameter_widget"
      via: "bridge method calls for state changes"
      pattern: "bridge\\.set_"
---

<objective>
Establish infrastructure for MCP tools to safely sync state with Streamlit UI widgets.

Purpose: When Claude calls state-modifying MCP tools (set-parameter, set-model, etc.), the changes must immediately reflect in the UI. This requires extending SessionStateBridge with setter methods and refactoring all tools to use the bridge instead of direct state access.

Output:
- SessionStateBridge with new setter methods for parameter widgets
- All state-modifying MCP tools refactored to use bridge methods
- Clean separation between tool logic and state management
</objective>

<execution_context>
@C:\Users\piotrrozyczko\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\piotrrozyczko\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure/01-RESEARCH.md

# Key source files
@src/sans_webapp/services/mcp_state_bridge.py
@src/sans_webapp/mcp_server.py
@src/sans_webapp/services/session_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SessionStateBridge with parameter widget setters</name>
  <files>src/sans_webapp/services/mcp_state_bridge.py</files>
  <action>
Add the following methods to the SessionStateBridge class:

1. Import `clamp_for_display` from `sans_webapp.services.session_state` at the top of the file.

2. Add `set_parameter_value(self, param_name: str, value: float) -> None`:
   - Sets `st.session_state[f'value_{param_name}']` to `clamp_for_display(value)`

3. Add `set_parameter_bounds(self, param_name: str, min_val: float, max_val: float) -> None`:
   - Sets `st.session_state[f'min_{param_name}']` to `clamp_for_display(min_val)`
   - Sets `st.session_state[f'max_{param_name}']` to `clamp_for_display(max_val)`

4. Add `set_parameter_vary(self, param_name: str, vary: bool) -> None`:
   - Sets `st.session_state[f'vary_{param_name}']` to `vary`

5. Add `set_parameter_widget(self, param_name: str, value: float | None = None, min_val: float | None = None, max_val: float | None = None, vary: bool | None = None) -> None`:
   - Convenience method that sets only the provided values
   - Each parameter is optional; only set if not None
   - Use `clamp_for_display` for numeric values

Place these methods in the "Parameter widget state management" section, after `clear_parameter_widgets()`.

WHY: Centralizing widget state mutations in the bridge provides type safety, consistent key naming, and proper value clamping. This avoids scattered `st.session_state[f'value_{name}']` patterns throughout the codebase.
  </action>
  <verify>
Run: `python -c "from sans_webapp.services.mcp_state_bridge import SessionStateBridge; b = SessionStateBridge(); print(hasattr(b, 'set_parameter_value'), hasattr(b, 'set_parameter_widget'))"`
Expected output: `True True`
  </verify>
  <done>
SessionStateBridge has four new methods: set_parameter_value, set_parameter_bounds, set_parameter_vary, set_parameter_widget. All use clamp_for_display for numeric values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor MCP tools to use bridge methods</name>
  <files>src/sans_webapp/mcp_server.py</files>
  <action>
Refactor mcp_server.py to use SessionStateBridge instead of direct state access:

1. **Update imports** (near top of file):
   - Add: `from sans_webapp.services.mcp_state_bridge import get_state_bridge`

2. **Remove the old accessor pattern**:
   - Keep `_fitter` global (needed for fitter access)
   - Remove `_state_accessor` global variable
   - Remove `set_state_accessor()` function
   - Update `_check_tools_enabled()` to use bridge: `return get_state_bridge().are_tools_enabled()`

3. **Refactor `set_model()` function** (lines ~188-212):
   - Replace `if _state_accessor is not None:` block with:
     ```python
     bridge = get_state_bridge()
     bridge.clear_parameter_widgets()  # Clear old model's widgets
     bridge.set_current_model(model_name)
     bridge.set_model_selected(True)
     bridge.set_fit_completed(False)
     bridge.set_needs_rerun(True)
     ```
   - WHY: Model changes need to clear old parameter widgets to avoid stale state

4. **Refactor `set_parameter()` function** (lines ~215-264):
   - Replace `if _state_accessor is not None:` block with:
     ```python
     bridge = get_state_bridge()
     bridge.set_parameter_widget(name, value=value, min_val=min_bound, max_val=max_bound, vary=vary)
     bridge.set_needs_rerun(True)
     ```

5. **Refactor `set_multiple_parameters()` function** (lines ~267-313):
   - At start of function, get bridge: `bridge = get_state_bridge()`
   - Inside the loop, after modifying `param`, also call:
     ```python
     bridge.set_parameter_widget(
         name,
         value=settings.get('value'),
         min_val=settings.get('min'),
         max_val=settings.get('max'),
         vary=settings.get('vary')
     )
     ```
   - Replace final `if _state_accessor is not None:` with `bridge.set_needs_rerun(True)`

6. **Refactor `enable_polydispersity()` function** (lines ~316-344):
   - Replace `if _state_accessor is not None:` with:
     ```python
     bridge = get_state_bridge()
     bridge.set_needs_rerun(True)
     ```

7. **Refactor `set_structure_factor()` function** (lines ~347-370):
   - Replace `if _state_accessor is not None:` with:
     ```python
     bridge = get_state_bridge()
     bridge.set_needs_rerun(True)
     ```

8. **Refactor `remove_structure_factor()` function** (lines ~373-391):
   - Replace `if _state_accessor is not None:` with:
     ```python
     bridge = get_state_bridge()
     bridge.set_needs_rerun(True)
     ```

9. **Refactor `run_fit()` function** (lines ~394-439):
   - Replace `if _state_accessor is not None:` block with:
     ```python
     bridge = get_state_bridge()
     bridge.set_fit_completed(True)
     bridge.set_fit_result(result)
     bridge.set_needs_rerun(True)
     ```

WHY removing _state_accessor: The accessor pattern bypassed the bridge, creating two paths for state mutation. Consolidating on the bridge provides consistent behavior, proper type safety, and centralized logic (like clamp_for_display for values).
  </action>
  <verify>
1. Verify no _state_accessor remains: `grep -c "_state_accessor" src/sans_webapp/mcp_server.py` should return 0
2. Verify bridge is used: `grep -c "get_state_bridge" src/sans_webapp/mcp_server.py` should return >= 1
3. Verify import exists: `grep "from sans_webapp.services.mcp_state_bridge import" src/sans_webapp/mcp_server.py`
4. Run tests if they exist: `python -m pytest tests/ -v --tb=short 2>/dev/null || echo "No tests or tests skipped"`
  </verify>
  <done>
All state-modifying MCP tools use SessionStateBridge methods. The _state_accessor pattern is completely removed. Every tool that modifies state calls bridge.set_needs_rerun(True) before returning.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full integration:

1. **Import check**: The module loads without errors
   ```bash
   python -c "from sans_webapp.mcp_server import mcp; print('MCP server loads OK')"
   ```

2. **Bridge methods exist**:
   ```bash
   python -c "from sans_webapp.services.mcp_state_bridge import SessionStateBridge; b = SessionStateBridge(); methods = ['set_parameter_value', 'set_parameter_bounds', 'set_parameter_vary', 'set_parameter_widget', 'clear_parameter_widgets']; print(all(hasattr(b, m) for m in methods))"
   ```
   Expected: `True`

3. **No direct state access in tools**:
   ```bash
   grep -E "_state_accessor|st\.session_state" src/sans_webapp/mcp_server.py | grep -v "^#" | wc -l
   ```
   Expected: `0` (no direct state access outside imports)

4. **Code style check**:
   ```bash
   ruff check src/sans_webapp/services/mcp_state_bridge.py src/sans_webapp/mcp_server.py
   ```
</verification>

<success_criteria>
1. SessionStateBridge has setter methods for parameter widgets (value, bounds, vary, widget)
2. All state-modifying MCP tools use bridge methods exclusively
3. No `_state_accessor` pattern remains in mcp_server.py
4. Every state-modifying tool sets `needs_rerun` via bridge before returning
5. Module imports succeed without errors
6. Code passes ruff linting
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-01-SUMMARY.md`
</output>
